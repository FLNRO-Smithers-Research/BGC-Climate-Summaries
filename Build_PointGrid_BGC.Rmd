---
title: "BuildClimateGridPoints"
author: "William H MacKenzie"
date: "17/10/2019"
output: html_document
---
#Script to create gridded points and intersect with State and BGC layers

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
library(dplyr)
library(rgdal)
library(sp)
library(raster)
library(rgeos)
library(maptools)
library(magrittr)
library(tibble)
library(tidyr)
library(sf)
library(tcltk)
library(foreach)
library(httr)
library(jsonlite)
library(randomForest)
library(data.table)
require(survey)
require(fasterize)
require(tibble)
require(maptools)
require(tictoc)
```

## Create Grid Points and Hex Raster for WNA
This block of code is to generate grids at 4k and 2k for analyses applied to the entire WNA study area.
This grid will remain standardized but the BGC membership or climate data can be updated. 
The Build_BGC_Climate_Summaries script will update the BGC membership of the grid

```{r create Grid for WNA, echo=FALSE}
tic()
CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
WNA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "WNA_Merge_States_WGS84")#layer = "USA_States"
# set projection
WNA <- spTransform(WNA, CRS.albers)
### Read in combine BGC layers
BGC <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "BGCv11_AB_BGCs")
BGC <- spTransform(BGC, CRS.albers)

####set projection to NAD83
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
WNA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "WNA_Merge_States")
WNA <- spTransform(WNA, CRS.albers)
### Reada in DEM for WNA and transform to NAD83
WNA_DEM <- raster("./inputs/SpatialFiles/DEMs/WNA_DEM_clipped.tif")
projection(WNA_DEM) <- CRS.NAD83

### set hex grid size here  
size <- 2000
  p <- spsample(WNA, cellsize = c(size), type = "hexagonal",offset = c(0, 0))# type "regular" (need 2 sizes)

  p2 <- spTransform(p, CRS.NAD83) # albers to lat long in NAD83

  coords <- p2@coords
  coords <- as.data.frame(coords)
  #extracts elevation for each point in p
  coords$elev <- raster::extract(WNA_DEM,p)
  colnames(coords) <- c("longitude","latitude","elevation")
  coords <- as_tibble(rownames_to_column(coords, var = "ID1"))
  #overlay of points over administrative boundaries
  WNA$State <- as.character (WNA$State)
pnt_state <- over(p, WNA[,"State"],  minDimension = 1, returnList = FALSE) 
  pnt_state <- as_tibble(rownames_to_column(pnt_state, var = "ID1"))

 # overlay points over BGC boundaries
BGC$BGC <- as.character(BGC$BGC)
pnt_BGC <- over(p, BGC[,"BGC"],  minDimension = 1, returnList = FALSE) 
  pnt_BGC <- as_tibble(rownames_to_column(pnt_BGC, var = "ID1"))
pts.info <- left_join(pnt_BGC, pnt_state,  by = "ID1")
pts.info <- left_join(pts.info, coords,  by = "ID1")
pts.info <- pts.info %>% drop_na(State)

pts.info2 <- pts.info %>% dplyr::select(ID1, State, latitude, longitude, elevation) #variable order for ClimateWNA
write.csv (pts.info2,  "./inputs/created/USA_1km_Grid.csv", row.names = FALSE) ### this file to be submitted to ClimateWNA

pts.spatial <- SpatialPointsDataFrame(pts.info[,4:5],
                    pts.info,    #the R object to convert
                    proj4string = CRS.NAD83)   # assign a CRS 

  writeOGR (obj = pts.spatial, dsn = "./inputs/created/USA_HexGrid_1k.shp", layer = "GridPoints", driver = "ESRI Shapefile", overwrite_layer = TRUE)
  
    ###create a hex spatial polygons layer to match points
       hexs <- HexPoints2SpatialPolygons(p)
        o <- as.data.frame(over(hexs, p))
        #o <- as.data.frame(st_intersects(hexs, p))
        row.names(o) <- row.names(hexs)
        hexs <- SpatialPolygonsDataFrame(hexs, data=o)
        #hexs2 <- gIntersection(hexs, WNA, byid = TRUE)
        hexs <- spTransform(hexs, CRS.albers)
        writeOGR (obj = hexs, dsn = "./inputs/created/USA_HexPoly_1k.shp", 
                  layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE) 
 toc()

```

##Build fine scale hex raster for USA_BGC build

Function from http://strimas.com/spatial/hexagonal-grids/
Creates a hex grid. Use this function for USBGC map build
x= polygon, cell

````{r grid function}
source("_Function_make_HexGrid.R")

CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
USA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "USA_States")
USA <- spTransform(USA, CRS.albers)
USA_buff <- gBuffer(USA, byid=FALSE, width = 2) ##expand size of USA to capture boundaries
size <- 8000
USA_BGC_pts <- make_grid(USA_buff, cell_diameter = size, clip = FALSE)
#convert to SpatialPointsDataFrame and write shape file
  p <- data.frame (ID1 = 1 :length(USA_BGC_pts))
  p2 <- SpatialPointsDataFrame(USA_BGC_pts, data = p)        

writeOGR (obj = p2, dsn = "./inputs/created/USA_HexGrid_8000m_new.shp", 
          layer = "GridPoints", driver = "ESRI Shapefile", overwrite_layer = TRUE)
#create CSV output for ClimateBC        
   p3 <- spTransform(USA_BGC_pts, CRS.NAD83) # to lat long in NAD83
  coords <- p3@coords
  coords <- as.data.frame(coords)
WNA_DEM <- raster("./inputs/SpatialFiles/DEMs/WNA_DEM_clipped.tif")
projection(WNA_DEM) <- CRS.NAD83
    coords$elev <- raster::extract(WNA_DEM,p3)
  colnames(coords) <- c("longitude","latitude","elevation")
  coords <- as_tibble(rownames_to_column(coords, var = "ID1"))
  #overlay of points over administrative boundaries
  USA$State <- as.character (USA$State)
  
pnt_state <- over(USA_BGC_pts, USA[,"State"],  minDimension = 1, returnList = FALSE) 
  pnt_state <- as_tibble(rownames_to_column(pnt_state, var = "ID1"))
pts.info <- left_join(pnt_state, coords,  by = "ID1")
pts.info2 <- pts.info %>% dplyr::select(ID1, State, latitude, longitude, elevation) #order for ClimateWNA
write.csv (pts.info2,  "./inputs/created/USA_8000m_Grid_Climate_new.csv", row.names = FALSE)         

  
  USA_BGC_hex <- make_hex (USA_buff, cell_diameter = size, clip = FALSE)
#convert to SpatialPolygonsDataFrame
  o <- data.frame (ID1 = 1 :length(USA_BGC_hex))
        USA_BGC_hex2 <- SpatialPolygonsDataFrame(USA_BGC_hex, data = o)
    writeOGR (obj = USA_BGC_hex2, dsn = "./inputs/created/USA_HexPoly_8000m_new.shp", layer = "HexPolys", driver = "ESRI Shapefile", overwrite_layer = TRUE)


```




#Some working scripts that could be adopted.

## Function from  https://dieghernan.github.io/201906_Beautiful1/

```{r function using sf}
stdh_gridpol = function(sf,
                        to = "fishnet",
                        gridsize = as.integer(
                          min(diff(st_bbox(sf)[c(1, 3)]),
                              diff(st_bbox(sf)[c(2, 4)])) /40),
                        sliver = 0.5) {
  if (!unique(st_geometry_type(sf)) %in% c("POLYGON", "MULTIPOLYGON")) {
    stop("Input should be  MULTIPOLYGON or POLYGON")
  }
  if (!to %in% c("fishnet", "puzzle", "honeycomb", "hexbin", "pixel")) {
    stop("'to' should be 'fishnet','puzzle','honeycomb','hexbin' or 'pixel'")
  }
  
  if (class(sf)[1] == "sf") {
    initial = sf
    initial$index_target = 1:nrow(initial)
  } else {
    initial = st_sf(index_target = 1:length(sf), geom = sf)
  }
  
  target = st_geometry(initial)
  
  if (to %in% c("fishnet", "puzzle")) {
    sq = T
  } else {
    sq = F
  }
  if (to == "pixel") {
    grid = st_make_grid(target,
                        gridsize,
                        crs = st_crs(initial),
                        what = "centers")
  } else {
    grid = st_make_grid(
      target,
      gridsize,
      crs = st_crs(initial),
      what = "polygons",
      square = sq
    )
  }
  grid = st_sf(index = 1:length(lengths(grid)), grid) # Add index
  if (to == "pixel") {
    cent_merge = st_join(grid, initial["index_target"], left = F)
    grid_new = st_buffer(cent_merge, gridsize / 2)
  } else {
    cent_grid = st_centroid(grid)
    cent_merge = st_join(cent_grid, initial["index_target"], left = F)
    grid_new = inner_join(grid, st_drop_geometry(cent_merge))
  }
  if (to %in% c("fishnet", "honeycomb", "pixel")) {
    geom = aggregate(
      grid_new,
      by = list(grid_new$index_target),
      FUN = min,
      do_union = FALSE
    )
  } else {
    geom = aggregate(
      st_buffer(grid_new, sliver),
      by = list(grid_new$index_target),
      FUN = min,
      do_union = TRUE
    )
  }
  if (class(initial)[1] == "sf") {
    fin = left_join(geom %>% select(index_target),
                    st_drop_geometry(initial)) %>%
      select(-index_target)
    fin = st_cast(fin, "MULTIPOLYGON")
    return(fin)
  } else {
    fin = st_cast(geom, "MULTIPOLYGON")
    return(st_geometry(fin))
  }
}

hon <- stdh_gridpol(USA_spatial, to = "honeycomb", gridsize = 50 * 1000)
hex <- stdh_gridpol(GB, to = "hexbin", gridsize = 50 * 1000)
pix <- stdh_gridpol(WNA, to = "pixel", gridsize = 50 * 1000)
```

### From
https://gist.github.com/rafapereirabr/e1b73de3b019f4623af09f7d8c697c79
```{r new hex function}
HexGrid <- function(mycellsize, originlpolygon) { 
    
  # Define size of hexagon bins in meters to create points
  HexPts <- spsample(originlpolygon, type="hexagonal", offset=c(0,0), cellsize=mycellsize)
  
  # Create Grid - transform into spatial polygons
  HexPols <- HexPoints2SpatialPolygons(HexPts)
  
  # convert to spatial polygon data frame
  df <- data.frame(idhex = getSpPPolygonsIDSlots(HexPols))
  row.names(df) <- getSpPPolygonsIDSlots(HexPols)
  hexgrid <- SpatialPolygonsDataFrame(HexPols, data =df)
  return(hexgrid)
}


###### 3: Create Hexagonal grid -------------------

# 500 meters
    hex_got <- HexGrid(100000, WNA)

        writeOGR (obj = hex_got, dsn = "./inputs/created/test_HexGrid.shp", 
                  layer = "HexGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE)  

```