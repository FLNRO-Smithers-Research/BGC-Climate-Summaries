---
title: "BuildClimateGridPoints"
author: "William H MacKenzie"
date: "17/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
library(dplyr)
library(rgdal)
library(sp)
library(raster)
library(rgeos)
library(maptools)
library(magrittr)
library(tibble)
library(tidyr)
library(sf)
library(tcltk)
library(foreach)
library(httr)
library(jsonlite)
library(randomForest)
library(data.table)
require(survey)
require(fasterize)
require(tibble)
require(maptools)
```

## Create Grid Points and Hex Raster for WNA
This block of code is to generate grids at 4k and 2k for analyses applied to the entire WNA study area.
This grid will remain standardized but the BGC membership or climate data can be updated.
The next block will update the BGC membership of the 

```{r create Grid for WNA, echo=FALSE}

CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
WNA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "WNA_Merge_States_WGS84")
WNA <- st_read
WNA_st <- st_sf(WNA)
# set projection
WNA <- st_transform(WNA, CRS.albers)
### Read in combine BGC layers
BGC <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "BGCv11_AB_BGCs")
BGC <- st_transform(BGC, CRS.albers)
### Reada in DEM for WNA and transform to NAD83
WNA_DEM <- raster("./inputs/SpatialFiles/DEMs/WNA_DEM_clipped.tif")
projection(WNA_DEM) <- CRS.NAD83

### set hex grid size here  
size <- 4000
#WNA_ext <- as(extent(WNA) + size, "SpatialPolygons")
  #projection(WNA_ext) <- projection(CRS.albers)
  p <- spsample(WNA, cellsize = c(size), type = "hexagonal",offset = c(0, 0))# type "regular" (need 2 sizes)
#p <- st_sample(WNA, cellsize = c(size), type = "hexagonal",offset = c(0, 0))# type "regular" (need 2 sizes)
####################
  p2 <- spTransform(p, CRS.NAD83) #to lat long in NAD83
  coords <- p2@coords
  coords <- as.data.frame(coords)
  #extracts elevation for each point in p
  coords$elev <- raster::extract(WNA_DEM,p)
  colnames(coords) <- c("longitude","latitude","elevation")
  coords <- as_tibble(rownames_to_column(coords, var = "ID1"))
  #overlay of points over administrative boundaries
  WNA$State <- as.character (WNA$State)
pnt_state <- over(p, WNA[,"State"],  minDimension = 1, returnList = FALSE) 
  pnt_state <- as_tibble(rownames_to_column(pnt_state, var = "ID1"))

 # overlay points over BGC boundaries
BGC$BGC <- as.character(BGC$BGC)
pnt_BGC <- over(p, BGC[,"BGC"],  minDimension = 1, returnList = FALSE) 
  pnt_BGC <- as_tibble(rownames_to_column(pnt_BGC, var = "ID1"))
pts.info <- left_join(pnt_BGC, pnt_state,  by = "ID1")
pts.info <- left_join(pts.info, coords,  by = "ID1")
   #  coords$BGC <- over(p,)
write.csv (pts.info,  "./inputs/created/WNA_100km_Grid.csv", row.names = FALSE) 
 pts.spatial <- SpatialPointsDataFrame(pts.info[,4:5],
                    pts.info,    #the R object to convert
                    proj4string = CRS.NAD83)   # assign a CRS 

  writeOGR (obj = pts.spatial, dsn = "./inputs/created/WNA_HexGrid_4k.shp", layer = "GridPoints", driver = "ESRI Shapefile", overwrite_layer = TRUE)
  
    ###create a hex spatial polygons layer to match points
       hexs <- HexPoints2SpatialPolygons(p)
        o <- as.data.frame(over(hexs, p))
        #o <- as.data.frame(st_intersects(hexs, p))
        row.names(o) <- row.names(hexs)
        hexs <- SpatialPolygonsDataFrame(hexs, data=o)
        #hexs2 <- gIntersection(hexs, WNA, byid = TRUE)
        hexs <- spTransform(hexs, CRS.albers)
        writeOGR (obj = hexs, dsn = "./inputs/created/WNA_HexPoly_4k.shp", 
                  layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE) 
  # 
#   hexs <- HexPoints2SpatialPolygons(pts.spatial, 100000)
#   hexs <- spTransform(hexs, CRS.albers)
#   hexs2 <- SpatialPolygonsDataFrame(hexs, p1, match.ID = FALSE)
#    writeOGR (obj = hexs2, dsn = "./inputs/created/WNA_HexPoly_100k.shp", layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE) 
```

##Build fine scale raster for USA_BGC build
```{r create Grid for WNA, echo=FALSE}

CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
USA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "USA_States")
# set projection
USA <- spTransform(WNA, CRS.albers)
WNA_DEM <- raster("./inputs/SpatialFiles/DEMs/WNA_DEM_clipped.tif")
projection(WNA_DEM) <- CRS.NAD83

### set hex grid size here  
size <- 500
#WNA_ext <- as(extent(WNA) + size, "SpatialPolygons")
  #projection(WNA_ext) <- projection(CRS.albers)
  p <- spsample(USA, cellsize = c(size), type = "hexagonal",offset = c(0, 0))# type "regular" (need 2 sizes)

####################
  p2 <- spTransform(p, CRS.NAD83) #to lat long in NAD83
  coords <- p2@coords
  coords <- as.data.frame(coords)
  #extracts elevation for each point in p
  coords$elev <- raster::extract(WNA_DEM,p)
  colnames(coords) <- c("longitude","latitude","elevation")
  coords <- as_tibble(rownames_to_column(coords, var = "ID1"))
  #overlay of points over administrative boundaries
  USA$State <- as.character (USA$State)
pnt_state <- over(p, USA[,"State"],  minDimension = 1, returnList = FALSE) 
  pnt_state <- as_tibble(rownames_to_column(pnt_state, var = "ID1"))

 # overlay points over BGC boundaries
BGC$BGC <- as.character(BGC$BGC)
pnt_BGC <- over(p, BGC[,"BGC"],  minDimension = 1, returnList = FALSE)
  pnt_BGC <- as_tibble(rownames_to_column(pnt_BGC, var = "ID1"))
pts.info <- left_join(pnt_BGC, pnt_state,  by = "ID1")
pts.info <- left_join(pts.info, coords,  by = "ID1")
 coords$BGC <- over(p,)
write.csv (pts.info,  "./inputs/created/USA_500m_Grid.csv", row.names = FALSE) 
 pts.spatial <- SpatialPointsDataFrame(pts.info[,4:5],
                    pts.info,    #the R object to convert
                    proj4string = CRS.NAD83)   # assign a CRS 

  writeOGR (obj = pts.spatial, dsn = "./inputs/created/USA_HexGrid_500m.shp", layer = "GridPoints", driver = "ESRI Shapefile", overwrite_layer = TRUE)
  
  ###create a hex spatial polygons layer to match points
       hexs <- HexPoints2SpatialPolygons(p)
        o <- as.data.frame(over(hexs, p)) ### this function is too slow
        row.names(o) <- row.names(hexs)
        hexs <- SpatialPolygonsDataFrame(hexs, data=o)
        #hexs2 <- gIntersection(hexs, WNA, byid = TRUE)
        hexs <- spTransform(hexs, CRS.albers)
        writeOGR (obj = hexs, dsn = "./inputs/created/USA_HexPoly_500m.shp", 
                  layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE)   
# 
#   hexs <- HexPoints2SpatialPolygons(pts.spatial, 100000)
#   hexs <- spTransform(hexs, CRS.albers)
#   hexs2 <- SpatialPolygonsDataFrame(hexs, p1, match.ID = FALSE)
#    writeOGR (obj = hexs2, dsn = "./inputs/created/WNA_HexPoly_100k.shp", layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE) 
```





```{r overlay States, echo = FALSE} 
###for BC (input 4 km grid, output is just BC points with BGC assigned)
grid <- fread("./inputs/created/WNA100km_Grid.csv", stringsAsFactors = FALSE, data.table = FALSE)
allUnits <- grid
BCwBGC <- foreach(BGC = allUnits, .combine = rbind) %do%{
  dat <- grid4BC
  pointsOrig <- dat
  coordinates(dat) <- c("long", "lat")
  #proj4string(dat) <- CRS("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
  #proj4string(dat) <- CRS("+init=epsg:4326") ##WGS84
  proj4string(dat) <- CRS("+init=epsg:4269") ##NAD83
  dat <- spTransform(dat, CRS.albers)  # standard albers projection for BC gov't data BCAlbers 
  
  tempPoly <- bec11[bec11$BGC_LABEL == BGC,]
  tempPoly <- as(tempPoly, "Spatial") ##conver to sp
  tempPoly <- spTransform(tempPoly, CRS.albers) 
  dat <- over(dat, tempPoly) ###which ones are inside the BGC
  pointsOrig <- pointsOrig[!is.na(dat$BGC_LABEL),] ###Remove points not inside BGC
  if(nrow(pointsOrig) > 0){ ###check that some points fall inside BGC
    pointsOrig$BGC <- BGC
    pointsOrig
  }
}
 BCwBGC$ID1 <-row.names(BCwBGC)
colnames(BCwBGC)[6] <- "ID2"
BC4kgrid2  <- BCwBGC [,c("ID1", "ID2","lat", "long", "el")]
write.csv (BC4kgrid2, "BC1kmGrid_mapped_BGC2.csv", row.names = FALSE)
```

Function from http://strimas.com/spatial/hexagonal-grids/
Creates a hex grid. Use this function for USBGC map build
x= polygon, cell
````{r grid function}
make_grid <- function(x, cell_diameter, cell_area, clip = FALSE) {
  if (missing(cell_diameter)) {
    if (missing(cell_area)) {
      stop("Must provide cell_diameter or cell_area")
    } else {
      cell_diameter <- sqrt(2 * cell_area / sqrt(3))
    }
  }
  ext <- as(extent(x) + cell_diameter, "SpatialPolygons")
  projection(ext) <- projection(x)
  # generate array of hexagon centers
  g <- spsample(ext, type = "hexagonal", cellsize = cell_diameter, 
                offset = c(0.5, 0.5))
   # clip to boundary of study area
  if (clip) {
    g <- gIntersection(g, x, byid = TRUE)
  } else {
    g <- g[x, ]
  }
  # clean up feature IDs
  row.names(g) <- as.character(1:length(g))
   return(g)
}
 
make_hex <- function(x, cell_diameter, cell_area, clip = FALSE) {

    if (missing(cell_diameter)) {
    if (missing(cell_area)) {
      stop("Must provide cell_diameter or cell_area")
    } else {
      cell_diameter <- sqrt(2 * cell_area / sqrt(3))
    }
  }
  ext <- as(extent(x) + cell_diameter, "SpatialPolygons")
  projection(ext) <- projection(x)
  # generate array of hexagon centers
  g2 <- spsample(ext, type = "hexagonal", cellsize = cell_diameter, 
                offset = c(0, 0))
  
     # convert center points to hexagons
  g2 <- HexPoints2SpatialPolygons(g2, dx = cell_diameter)
  # clip to boundary of study area
  if (clip) {
    g2 <- gIntersection(g2, x, byid = TRUE)
  } else {
    g2 <- g2[x, ]
  }
  # clean up feature IDs
  row.names(g2) <- as.character(1:length(g2))
  return(g2)
}

CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
USA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "USA_States")
USA <- spTransform(USA, CRS.albers)
size <- 100000
USA_BGC_pts <- make_grid(USA, cell_diameter = size, clip = FALSE)
USA_BGC_hex <- make_hex (USA, cell_diameter = size, clip = TRUE)




# without clipping
hex_grid <- make_grid(USA_BGC_NAD83, cell_area = 625, clip = FALSE)
plot(USA_BGC_hex, col = "grey50", bg = "light blue", axes = FALSE)
plot(hex_grid, border = "orange", add = TRUE)
box()
# with clipping
hex_grid <- make_grid(study_area_utm, cell_area = 625, clip = TRUE)
plot(study_area_utm, col = "grey50", bg = "light blue", axes = FALSE)
plot(hex_grid, border = "orange", add = TRUE)
box()
```

## Function from  https://dieghernan.github.io/201906_Beautiful1/

```{r function using sf}
stdh_gridpol = function(sf,
                        to = "fishnet",
                        gridsize = as.integer(
                          min(diff(st_bbox(sf)[c(1, 3)]),
                              diff(st_bbox(sf)[c(2, 4)])) /40),
                        sliver = 0.5) {
  if (!unique(st_geometry_type(sf)) %in% c("POLYGON", "MULTIPOLYGON")) {
    stop("Input should be  MULTIPOLYGON or POLYGON")
  }
  if (!to %in% c("fishnet", "puzzle", "honeycomb", "hexbin", "pixel")) {
    stop("'to' should be 'fishnet','puzzle','honeycomb','hexbin' or 'pixel'")
  }
  
  if (class(sf)[1] == "sf") {
    initial = sf
    initial$index_target = 1:nrow(initial)
  } else {
    initial = st_sf(index_target = 1:length(sf), geom = sf)
  }
  
  target = st_geometry(initial)
  
  if (to %in% c("fishnet", "puzzle")) {
    sq = T
  } else {
    sq = F
  }
  if (to == "pixel") {
    grid = st_make_grid(target,
                        gridsize,
                        crs = st_crs(initial),
                        what = "centers")
  } else {
    grid = st_make_grid(
      target,
      gridsize,
      crs = st_crs(initial),
      what = "polygons",
      square = sq
    )
  }
  grid = st_sf(index = 1:length(lengths(grid)), grid) # Add index
  if (to == "pixel") {
    cent_merge = st_join(grid, initial["index_target"], left = F)
    grid_new = st_buffer(cent_merge, gridsize / 2)
  } else {
    cent_grid = st_centroid(grid)
    cent_merge = st_join(cent_grid, initial["index_target"], left = F)
    grid_new = inner_join(grid, st_drop_geometry(cent_merge))
  }
  if (to %in% c("fishnet", "honeycomb", "pixel")) {
    geom = aggregate(
      grid_new,
      by = list(grid_new$index_target),
      FUN = min,
      do_union = FALSE
    )
  } else {
    geom = aggregate(
      st_buffer(grid_new, sliver),
      by = list(grid_new$index_target),
      FUN = min,
      do_union = TRUE
    )
  }
  if (class(initial)[1] == "sf") {
    fin = left_join(geom %>% select(index_target),
                    st_drop_geometry(initial)) %>%
      select(-index_target)
    fin = st_cast(fin, "MULTIPOLYGON")
    return(fin)
  } else {
    fin = st_cast(geom, "MULTIPOLYGON")
    return(st_geometry(fin))
  }
}
```