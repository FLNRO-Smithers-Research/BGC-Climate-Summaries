---
title: "BuildClimateGridPoints"
author: "William H MacKenzie"
date: "17/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
library(dplyr)
library(rgdal)
library(sp)
library(raster)
library(rgeos)
library(maptools)
library(magrittr)
library(tibble)
library(tidyr)
library(sf)
library(tcltk)
library(foreach)
library(httr)
library(jsonlite)
library(randomForest)
library(data.table)
require(survey)
require(fasterize)
require(tibble)
require(maptools)
require(tictoc)
```

## Create Grid Points and Hex Raster for WNA
This block of code is to generate grids at 4k and 2k for analyses applied to the entire WNA study area.
This grid will remain standardized but the BGC membership or climate data can be updated. 
The Build_BGC_Climate_Summaries script will update the BGC membership of the grid

```{r create Grid for WNA, echo=FALSE}
tic()
CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
WNA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "WNA_Merge_States_WGS84")#layer = "USA_States"
#WNA <- read_sf("./inputs/SpatialFiles/BC_AB_US_Shp/WNA_Merge_States_WGS84.shp)
# set projection
WNA <- spTransform(WNA, CRS.albers)
#WNA <- st_transform(WNA, CRS.albers)
### Read in combine BGC layers
BGC <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "BGCv11_AB_BGCs")
#BGC <- read_sf("./inputs/SpatialFiles/BC_AB_US_Shp/BGCv11_AB_BGCs.shp)
BGC <- spTransform(BGC, CRS.albers)
#BGC <- st_transform(BGC, CRS.albers)
### Reada in DEM for WNA and transform to NAD83
WNA_DEM <- raster("./inputs/SpatialFiles/DEMs/WNA_DEM_clipped.tif")
projection(WNA_DEM) <- CRS.NAD83

### set hex grid size here  
size <- 2000
#WNA_ext <- as(extent(WNA) + size, "SpatialPolygons")
  #projection(WNA_ext) <- projection(CRS.albers)
  p <- spsample(WNA, cellsize = c(size), type = "hexagonal",offset = c(0, 0))# type "regular" (need 2 sizes)
#p <- st_sample(WNA, size = size, type = "hexagonal",offset = c(0, 0))# type "regular" (need 2 sizes)
####################
  p2 <- spTransform(p, CRS.NAD83) # to lat long in NAD83
  #p2 <- st_transform(p2, CRS.NAD83)
  coords <- p2@coords
  #coords <- st_coordinates (p2)
  coords <- as.data.frame(coords)
  #extracts elevation for each point in p
  coords$elev <- raster::extract(WNA_DEM,p)
  colnames(coords) <- c("longitude","latitude","elevation")
  coords <- as_tibble(rownames_to_column(coords, var = "ID1"))
  #overlay of points over administrative boundaries
  WNA$State <- as.character (WNA$State)
pnt_state <- over(p, WNA[,"State"],  minDimension = 1, returnList = FALSE) 
  pnt_state <- as_tibble(rownames_to_column(pnt_state, var = "ID1"))

 # overlay points over BGC boundaries
BGC$BGC <- as.character(BGC$BGC)
pnt_BGC <- over(p, BGC[,"BGC"],  minDimension = 1, returnList = FALSE) 
  pnt_BGC <- as_tibble(rownames_to_column(pnt_BGC, var = "ID1"))
pts.info <- left_join(pnt_BGC, pnt_state,  by = "ID1")
pts.info <- left_join(pts.info, coords,  by = "ID1")
pts.info <- pts.info %>% drop_na(State)
#pts.info <- as.data.frame(pts.info)
   #  coords$BGC <- over(p,)
pts.info2 <- pts.info %>% dplyr::select(ID1, State, latitude, longitude, elevation) #order for ClimateWNA
write.csv (pts.info2,  "./inputs/created/USA_1km_Grid.csv", row.names = FALSE) 

pts.spatial <- SpatialPointsDataFrame(pts.info[,4:5],
                    pts.info,    #the R object to convert
                    proj4string = CRS.NAD83)   # assign a CRS 

  writeOGR (obj = pts.spatial, dsn = "./inputs/created/USA_HexGrid_1k.shp", layer = "GridPoints", driver = "ESRI Shapefile", overwrite_layer = TRUE)
  
    ###create a hex spatial polygons layer to match points
       hexs <- HexPoints2SpatialPolygons(p)
        o <- as.data.frame(over(hexs, p))
        #o <- as.data.frame(st_intersects(hexs, p))
        row.names(o) <- row.names(hexs)
        hexs <- SpatialPolygonsDataFrame(hexs, data=o)
        #hexs2 <- gIntersection(hexs, WNA, byid = TRUE)
        hexs <- spTransform(hexs, CRS.albers)
        writeOGR (obj = hexs, dsn = "./inputs/created/USA_HexPoly_1k.shp", 
                  layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE) 
 toc()
         # 
#   hexs <- HexPoints2SpatialPolygons(pts.spatial, 100000)
#   hexs <- spTransform(hexs, CRS.albers)
#   hexs2 <- SpatialPolygonsDataFrame(hexs, p1, match.ID = FALSE)
#    writeOGR (obj = hexs2, dsn = "./inputs/created/WNA_HexPoly_100k.shp", layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE) 
```

##Build fine scale hex raster for USA_BGC build

Function from http://strimas.com/spatial/hexagonal-grids/
Creates a hex grid. Use this function for USBGC map build
x= polygon, cell

````{r grid function}
source("Function_make_HexGrid.R")

CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

### Read in the combined state boundary files for WNA
USA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "USA_States")
USA <- spTransform(USA, CRS.albers)
USA_buff <- gBuffer(USA, byid=FALSE, width = 1.1) ##expand size of USA to capture boundaries

size <- 800
USA_BGC_pts <- make_grid(USA_buff, cell_diameter = size, clip = FALSE)
#convert to SpatialPointsDataFrame
  p <- data.frame (ID1 = 1 :length(USA_BGC_pts))
        USA_BGC_pts2 <- SpatialPointsDataFrame(USA_BGC_pts, data = p)        
writeOGR (obj = USA_BGC_pts2, dsn = "./inputs/created/USA_HexGrid_1k_new.shp", layer = "GridPoints", driver = "ESRI Shapefile", overwrite_layer = TRUE)
         
   p2 <- spTransform(USA_BGC_pts, CRS.NAD83) # to lat long in NAD83
  coords <- p2@coords
  coords <- as.data.frame(coords)
WNA_DEM <- raster("./inputs/SpatialFiles/DEMs/WNA_DEM_clipped.tif")
projection(WNA_DEM) <- CRS.NAD83
    coords$elev <- raster::extract(WNA_DEM,p2)
  colnames(coords) <- c("longitude","latitude","elevation")
  coords <- as_tibble(rownames_to_column(coords, var = "ID1"))
  #overlay of points over administrative boundaries
  USA$State <- as.character (USA$State)
  
pnt_state <- over(USA_BGC_pts, USA[,"State"],  minDimension = 1, returnList = FALSE) 
  pnt_state <- as_tibble(rownames_to_column(pnt_state, var = "ID1"))
pts.info <- left_join(pnt_state, coords,  by = "ID1")
pts.info2 <- pts.info %>% dplyr::select(ID1, State, latitude, longitude, elevation) #order for ClimateWNA
write.csv (pts.info2,  "./inputs/created/USA_1km_Grid_Climate.csv", row.names = FALSE)         

  
  USA_BGC_hex <- make_hex (USA_buff, cell_diameter = size, clip = FALSE)
#convert to SpatialPolygonsDataFrame
  o <- data.frame (ID1 = 1 :length(USA_BGC_hex))
        USA_BGC_hex2 <- SpatialPolygonsDataFrame(USA_BGC_hex, data = o)
    writeOGR (obj = USA_BGC_hex2, dsn = "./inputs/created/USA_HexPoly_1k_new.shp", layer = "HexPolys", driver = "ESRI Shapefile", overwrite_layer = TRUE)

  
  # # without clipping
# hex_grid <- make_grid(USA_BGC_hex, cell_area = 625, clip = FALSE)
# plot(USA_BGC_hex, col = "grey50", bg = "light blue", axes = FALSE)
# plot(hex_grid, border = "orange", add = TRUE)
# box()
# # with clipping
# hex_grid <- make_grid(study_area_utm, cell_area = 625, clip = TRUE)
# plot(study_area_utm, col = "grey50", bg = "light blue", axes = FALSE)
# plot(hex_grid, border = "orange", add = TRUE)
# box()
```


```{r create Grid for WNA, echo=FALSE}

CRS.albers <- CRS ("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
CRS.NAD83 <- CRS("+init=epsg:4269")

USA <- "./inputs/SpatialFiles/BC_AB_US_Shp/USA_States.shp"#spatial file of BGC
#mydata2 <- mydata[mydata$State == "BC",] #limit locations to BC
USA_spatial <-  read_sf (USA) %>% st_set_crs (CRS.albers)

USA_grid <- st_make_grid(USA_spatial, cellsize = 10*10)

mydata3 <- st_join(mydata_spatial, BGC_spatial) %>% st_transform(CRS.NAD83)### add BGC variables to climate data
mydata4 <- as.data.frame(mydata3) %>% drop_na("State")
mydata4 <- mydata4 %>% dplyr::select("ID1", "State", "BGC", "lat", "long", "Elevation", everything())
mydata4 <- mydata4[!(mydata$MAT == -9999.0),] # removes [points that are outside of climateBC model]
write.csv(mydata4, a) ##replaces the orginal file
save(mydata4,file=paste("./inputs/created/",fname,".Rdata",sep="")) # save as an RDA for future applications
### Read in the combined state boundary files for WNA
USA <- readOGR(dsn = "./inputs/SpatialFiles/BC_AB_US_Shp", layer = "USA_States")
# set projection
USA <- spTransform(WNA, CRS.albers)
WNA_DEM <- raster("./inputs/SpatialFiles/DEMs/WNA_DEM_clipped.tif")
projection(WNA_DEM) <- CRS.NAD83

### set hex grid size here  
size <- 500
#WNA_ext <- as(extent(WNA) + size, "SpatialPolygons")
  #projection(WNA_ext) <- projection(CRS.albers)
  p <- spsample(USA, cellsize = c(size), type = "hexagonal",offset = c(0, 0))# type "regular" (need 2 sizes)

####################
  p2 <- spTransform(p, CRS.NAD83) #to lat long in NAD83
  coords <- p2@coords
  coords <- as.data.frame(coords)
  #extracts elevation for each point in p
  coords$elev <- raster::extract(WNA_DEM,p)
  colnames(coords) <- c("longitude","latitude","elevation")
  coords <- as_tibble(rownames_to_column(coords, var = "ID1"))
  #overlay of points over administrative boundaries
  USA$State <- as.character (USA$State)
pnt_state <- over(p, USA[,"State"],  minDimension = 1, returnList = FALSE) 
  pnt_state <- as_tibble(rownames_to_column(pnt_state, var = "ID1"))

 # overlay points over BGC boundaries
BGC$BGC <- as.character(BGC$BGC)
pnt_BGC <- over(p, BGC[,"BGC"],  minDimension = 1, returnList = FALSE)
  pnt_BGC <- as_tibble(rownames_to_column(pnt_BGC, var = "ID1"))
pts.info <- left_join(pnt_BGC, pnt_state,  by = "ID1")
pts.info <- left_join(pts.info, coords,  by = "ID1")
 coords$BGC <- over(p,)
write.csv (pts.info,  "./inputs/created/USA_500m_Grid.csv", row.names = FALSE) 
 pts.spatial <- SpatialPointsDataFrame(pts.info[,4:5],
                    pts.info,    #the R object to convert
                    proj4string = CRS.NAD83)   # assign a CRS 

  writeOGR (obj = pts.spatial, dsn = "./inputs/created/USA_HexGrid_500m.shp", layer = "GridPoints", driver = "ESRI Shapefile", overwrite_layer = TRUE)
  
  ###create a hex spatial polygons layer to match points
       hexs <- HexPoints2SpatialPolygons(p)
        o <- as.data.frame(over(hexs, p)) ### this function is too slow
        row.names(o) <- row.names(hexs)
        hexs <- SpatialPolygonsDataFrame(hexs, data=o)
        #hexs2 <- gIntersection(hexs, WNA, byid = TRUE)
        hexs <- spTransform(hexs, CRS.albers)
        writeOGR (obj = hexs, dsn = "./inputs/created/USA_HexPoly_500m.shp", 
                  layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE)   
# 
#   hexs <- HexPoints2SpatialPolygons(pts.spatial, 100000)
#   hexs <- spTransform(hexs, CRS.albers)
#   hexs2 <- SpatialPolygonsDataFrame(hexs, p1, match.ID = FALSE)
#    writeOGR (obj = hexs2, dsn = "./inputs/created/WNA_HexPoly_100k.shp", layer = "HexPolyGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE) 
```





```{r overlay States, echo = FALSE} 
###for BC (input 4 km grid, output is just BC points with BGC assigned)
grid <- fread("./inputs/created/WNA100km_Grid.csv", stringsAsFactors = FALSE, data.table = FALSE)
allUnits <- grid
BCwBGC <- foreach(BGC = allUnits, .combine = rbind) %do%{
  dat <- grid4BC
  pointsOrig <- dat
  coordinates(dat) <- c("long", "lat")
  #proj4string(dat) <- CRS("+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")
  #proj4string(dat) <- CRS("+init=epsg:4326") ##WGS84
  proj4string(dat) <- CRS("+init=epsg:4269") ##NAD83
  dat <- spTransform(dat, CRS.albers)  # standard albers projection for BC gov't data BCAlbers 
  
  tempPoly <- bec11[bec11$BGC_LABEL == BGC,]
  tempPoly <- as(tempPoly, "Spatial") ##conver to sp
  tempPoly <- spTransform(tempPoly, CRS.albers) 
  dat <- over(dat, tempPoly) ###which ones are inside the BGC
  pointsOrig <- pointsOrig[!is.na(dat$BGC_LABEL),] ###Remove points not inside BGC
  if(nrow(pointsOrig) > 0){ ###check that some points fall inside BGC
    pointsOrig$BGC <- BGC
    pointsOrig
  }
}
 BCwBGC$ID1 <-row.names(BCwBGC)
colnames(BCwBGC)[6] <- "ID2"
BC4kgrid2  <- BCwBGC [,c("ID1", "ID2","lat", "long", "el")]
write.csv (BC4kgrid2, "BC1kmGrid_mapped_BGC2.csv", row.names = FALSE)
```



## Function from  https://dieghernan.github.io/201906_Beautiful1/

```{r function using sf}
stdh_gridpol = function(sf,
                        to = "fishnet",
                        gridsize = as.integer(
                          min(diff(st_bbox(sf)[c(1, 3)]),
                              diff(st_bbox(sf)[c(2, 4)])) /40),
                        sliver = 0.5) {
  if (!unique(st_geometry_type(sf)) %in% c("POLYGON", "MULTIPOLYGON")) {
    stop("Input should be  MULTIPOLYGON or POLYGON")
  }
  if (!to %in% c("fishnet", "puzzle", "honeycomb", "hexbin", "pixel")) {
    stop("'to' should be 'fishnet','puzzle','honeycomb','hexbin' or 'pixel'")
  }
  
  if (class(sf)[1] == "sf") {
    initial = sf
    initial$index_target = 1:nrow(initial)
  } else {
    initial = st_sf(index_target = 1:length(sf), geom = sf)
  }
  
  target = st_geometry(initial)
  
  if (to %in% c("fishnet", "puzzle")) {
    sq = T
  } else {
    sq = F
  }
  if (to == "pixel") {
    grid = st_make_grid(target,
                        gridsize,
                        crs = st_crs(initial),
                        what = "centers")
  } else {
    grid = st_make_grid(
      target,
      gridsize,
      crs = st_crs(initial),
      what = "polygons",
      square = sq
    )
  }
  grid = st_sf(index = 1:length(lengths(grid)), grid) # Add index
  if (to == "pixel") {
    cent_merge = st_join(grid, initial["index_target"], left = F)
    grid_new = st_buffer(cent_merge, gridsize / 2)
  } else {
    cent_grid = st_centroid(grid)
    cent_merge = st_join(cent_grid, initial["index_target"], left = F)
    grid_new = inner_join(grid, st_drop_geometry(cent_merge))
  }
  if (to %in% c("fishnet", "honeycomb", "pixel")) {
    geom = aggregate(
      grid_new,
      by = list(grid_new$index_target),
      FUN = min,
      do_union = FALSE
    )
  } else {
    geom = aggregate(
      st_buffer(grid_new, sliver),
      by = list(grid_new$index_target),
      FUN = min,
      do_union = TRUE
    )
  }
  if (class(initial)[1] == "sf") {
    fin = left_join(geom %>% select(index_target),
                    st_drop_geometry(initial)) %>%
      select(-index_target)
    fin = st_cast(fin, "MULTIPOLYGON")
    return(fin)
  } else {
    fin = st_cast(geom, "MULTIPOLYGON")
    return(st_geometry(fin))
  }
}

hon <- stdh_gridpol(USA_spatial, to = "honeycomb", gridsize = 50 * 1000)
hex <- stdh_gridpol(GB, to = "hexbin", gridsize = 50 * 1000)
pix <- stdh_gridpol(WNA, to = "pixel", gridsize = 50 * 1000)
```

### From
https://gist.github.com/rafapereirabr/e1b73de3b019f4623af09f7d8c697c79
```{r new hex function}
HexGrid <- function(mycellsize, originlpolygon) { 
    
  # Define size of hexagon bins in meters to create points
  HexPts <- spsample(originlpolygon, type="hexagonal", offset=c(0,0), cellsize=mycellsize)
  
  # Create Grid - transform into spatial polygons
  HexPols <- HexPoints2SpatialPolygons(HexPts)
  
  # convert to spatial polygon data frame
  df <- data.frame(idhex = getSpPPolygonsIDSlots(HexPols))
  row.names(df) <- getSpPPolygonsIDSlots(HexPols)
  hexgrid <- SpatialPolygonsDataFrame(HexPols, data =df)
  return(hexgrid)
}


###### 3: Create Hexagonal grid -------------------

# 500 meters
    hex_got <- HexGrid(100000, WNA)

        writeOGR (obj = hex_got, dsn = "./inputs/created/test_HexGrid.shp", 
                  layer = "HexGrid", driver = "ESRI Shapefile", overwrite_layer = TRUE)  

```